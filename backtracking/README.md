## BackTracking

---

< 개념 >

- 해를 찾는 도중 해가 아니어서 막히면 다시 되돌아가서 해를 찾아가는 기법. 주로 최적화 문제와 결정 문제를 푸는 방법이 된다.
- DFS와 백트래킹의 차이
  - DFS는 가능한 모든 경우의 수를 탐색. 따라서, 불필요한 경우의 수를 줄이지 못함.
    - 따라서 n!가지의 경우의 수를 가진 문제의 경우 DFS로 처리 불가능
  - 백트래킹은 현재의 경로가 정답이 아니면 해당 경로를 더이상 탐색하지 않고 돌아간다. 때문에 반복문의 수가 줄어들어 효율적. <- 이것을 가지치기라고도 함.
    - 그러나, n!의 경우의 수를 가지는 문제에서 최악의 경우에는 여전히 지수함수 시간을 필요로 하므로 처리가 불가능할 수도 있음. 따라서, 가지치기를 얼마나 잘하냐가 중요하다.
- 구현 방법 : DFS 등으로 모든 경우의 수를 찾는 과정에서 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의. 그러한 상황의 경우 탐색 중지 후 다른 경우의 수를 탐색할 수 있도록 구현 가능.
- 결론 : 백트래킹이란 문제의 해가 될 수 있는지 판단 후 해가 아니면 탐색하지 않고 가지치기 하는 방법

---

< 푼 문제들 >

- 15649 : 백트레킹 기초 문제, 가지치기하는데 오래 걸려서 당황했음. dfs 개념을 다시 재정립할 필요가 있다.
- 15650 : 15649번 문제에서 오름차순인지 확인하는 조건문을 작성하면 되었다. 때문에, `sorted(arr) == arr` 문장을 추가하여 오름차순인지 확인해주었다.
- 15651 : 15649번에서 중복을 허용하기 때문에 `if i not in arr` 만 빼주었다. i가 arr 배열 안에 있으면 중복이기 때문이다. 근데 이거는 백트래킹보다는 가능한 모든 경우의 수를 찾는 dfs인 것 같다는 생각이 들긴 했다.
- 15652 : 처음에는 15650처럼 `sorted(arr) == arr`을 넣어서 풀려고 했으나, 시간초과가 발생. 때문에, sorted(arr) 자체가 오래 걸린다고 판단하여 dfs를 수행할 때, i 값을 넘겨줌으로써 해당 i번째부터 n까지 모든 경우의 수를 고려하도록 하였음.
